<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Algoritmos</title>
	<style>
		table, th, td {
			border: 1px solid black;
			border-collapse: collapse;
			padding: 8px;
			text-align: center;
		}
		.coluna-destaque {
			background-color: #f2f2f2;
		}
		h5 {
  			font-size: 1em;
		}
		h4 {
			text-decoration: underline;
		}
	</style>
</head>
<body>
	<div>
		<h1>li√ß√µes de casa</h1>
		<h2>an√°lise de tempo dos algoritmos insertion sort, bubble sort e selectionsort.</h2>
		<h3>mas primeiro irei reconceituar os algoritmos de ordena√ß√£o:</h3>

		<p>esses 3 algoritmos s√£o m√©todos cl√°ssicos de ordena√ß√£o de elementos em uma lista. Eles s√£o relativamente simples de entender e implementar, mas podem ser ineficientes em grandes conjuntos de dados.</p>
		<ul>
			<h4>insertion sort</h4>
			<li>
				<p>
					O algoritmo de Insertion Sort √© um algoritmo de ordena√ß√£o que percorre uma lista de elementos e insere cada elemento em sua posi√ß√£o correta na parte j√° ordenada da lista. Esse processo √© repetido at√© que todos os elementos da lista estejam na posi√ß√£o correta, resultando em uma lista ordenada. <br> <br>

					O algoritmo de Insertion Sort √© implementado com um la√ßo externo que percorre a lista a ser ordenada, come√ßando do segundo elemento e indo at√© o √∫ltimo. Para cada elemento, o algoritmo realiza um la√ßo interno que percorre a parte j√° ordenada da lista, do final para o in√≠cio, e insere o elemento na posi√ß√£o correta. <br> <br>

					O processo de inser√ß√£o √© realizado comparando o elemento atual com o elemento anterior na lista j√° ordenada. Se o elemento atual for menor que o elemento anterior, os dois elementos s√£o trocados. Esse processo de compara√ß√£o e troca √© repetido at√© que o elemento atual encontre a sua posi√ß√£o correta na lista j√° ordenada. <br> <br>

					O Insertion Sort √© um pouco mais eficiente que o Bubble Sort, mas ainda pode ser ineficiente para listas muito grandes. Sua complexidade de tempo √© O(n^2), o que significa que o tempo de execu√ß√£o cresce exponencialmente com o tamanho da lista.
				</p>
				<h5>exemplo em pseudo-c√≥digo:</h5>
				<code>
					insertionSort(lista): <br>
					n = tamanho(lista) <br>
					para i de 1 at√© n-1: <br>
					  chave = lista[i] <br>
					  j = i-1 <br>
					  enquanto j >= 0 e lista[j] > chave: <br>
						lista[j+1] = lista[j] <br>
						j = j-1 <br>
					  lista[j+1] = chave <br>
					retornar lista <br>
				</code>
				<br>
			</li>
			<h4>bubble sort</h4>
			<li>
				<p>
					O algoritmo de Bubble Sort √© um algoritmo de ordena√ß√£o que percorre a lista v√°rias vezes, comparando cada elemento com o seu vizinho e trocando de posi√ß√£o caso esteja fora de ordem. Esse processo √© repetido at√© que nenhum elemento precise mais ser trocado de posi√ß√£o, resultando em uma lista ordenada.  <br> <br>

					O algoritmo de Bubble Sort √© implementado com um la√ßo externo que percorre a lista a ser ordenada, comparando cada elemento com o seu vizinho imediato e trocando de posi√ß√£o se necess√°rio. Esse processo √© repetido at√© que todos os elementos da lista estejam na posi√ß√£o correta.  <br> <br>

					Durante cada itera√ß√£o do la√ßo externo, o algoritmo percorre a lista com um la√ßo interno, comparando o elemento atual com o seu vizinho imediato e trocando de posi√ß√£o se o elemento atual for maior que o seu vizinho. Esse processo √© repetido at√© que o final da lista seja alcan√ßado.  <br> <br>

					O processo de troca de posi√ß√µes √© realizado comparando o elemento atual com o seu vizinho imediato. Se o elemento atual for maior que o seu vizinho, os dois elementos s√£o trocados de posi√ß√£o. Esse processo de compara√ß√£o e troca √© repetido at√© que a lista esteja completamente ordenada. <br> <br>

					Embora seja f√°cil de entender e implementar, o Bubble Sort √© um algoritmo ineficiente, especialmente para listas grandes. Sua complexidade de tempo √© O(n^2), o que significa que o tempo de execu√ß√£o cresce exponencialmente com o tamanho da lista.
				</p>
				<h5>exemplo em pseudo-c√≥digo:</h5>
				<code>
					bubbleSort(lista): <br>
					n = tamanho(lista) <br>
					para i de 0 at√© n-1: <br>
					  para j de 0 at√© n-i-1: <br>
						se lista[j] > lista[j+1]: <br>
						  trocar(lista[j], lista[j+1]) <br> 
					retornar lista <br>
					<br>
					fun√ß√£o trocar(a, b) <br>
					temp = a <br>
					a = b <br>
					b = temp <br> 
					fim fun√ß√£o <br>
				</code>

			</li>
			<br>
			
			<h4>selection sort</h4>
			<li>
				<p>
					O algoritmo de Selection Sort √© um algoritmo de ordena√ß√£o que seleciona o menor elemento da lista e o coloca na primeira posi√ß√£o, o segundo menor elemento √© colocado na segunda posi√ß√£o, e assim sucessivamente. Esse processo √© repetido at√© que todos os elementos da lista estejam na posi√ß√£o correta, resultando em uma lista ordenada.<br> <br>

					O algoritmo de Selection Sort √© implementado com um la√ßo externo que percorre a lista a ser ordenada, selecionando o menor elemento e colocando-o na primeira posi√ß√£o da lista. Em seguida, o la√ßo externo avan√ßa para a pr√≥xima posi√ß√£o e repete o processo, selecionando o menor elemento na parte restante da lista e colocando-o na posi√ß√£o correta.<br> <br>

					O processo de sele√ß√£o √© realizado comparando cada elemento da lista com o menor elemento encontrado at√© o momento. Se um elemento for encontrado que seja menor que o menor elemento atual, ele se torna o novo menor elemento. Esse processo de compara√ß√£o √© repetido at√© que o menor elemento da lista seja encontrado. Depois de encontrar o menor elemento, ele √© colocado na posi√ß√£o correta na lista, e o processo de sele√ß√£o continua para o restante da lista. <br> <br>

					O Selection Sort √© mais eficiente que o Bubble Sort e o Insertion Sort, mas ainda pode ser ineficiente para listas muito grandes. Sua complexidade de tempo tamb√©m √© O(n^2).
				</p>
				<h5>exemplo em pseudo-c√≥digo:</h5>
				<code>
					selectionSort(lista): <br>
					n = tamanho(lista) <br>
					para i de 0 at√© n-1: <br>
						indice_minimo = i <br>
						para j de i+1 at√© n-1: <br>
						se lista[j] < lista[indice_minimo]: <br>
							indice_minimo = j <br>
						se indice_minimo != i: <br>
						trocar(lista[i], lista[indice_minimo]) <br>
					retornar lista <br>
					<br>
					fun√ß√£o trocar(a, b) <br>
					temp = a <br>
					a = b <br>
					b = temp <br> 
					fim fun√ß√£o <br>
				</code>
			</li>
		</ul>
		<div>
			<h2>comparativos de velocidade entre os 3 algoritmos supracitados:</h2>
			<table colgroup>
				<col>
				<col span="1" style="border-right: 1px solid black;">
				<col>
				<col span="1" style="border-right: 1px solid black;">
				<col>
				<tr>
					<th>Algoritmo</th>
					<th>Melhor caso</th>
					<th>Pior caso</th>
					<th>Caso m√©dio</th>
					<th>Estabilidade</th>
				</tr>
				<tr>
					<td>Bubble Sort</td>
					<td>O(n)</td>
					<td>O(n^2)</td>
					<td>O(n^2)</td>
					<td>Est√°vel</td>
				</tr>
				<tr>
					<td>Insertion Sort</td>
					<td>O(n)</td>
					<td>O(n^2)</td>
					<td>O(n^2)</td>
					<td>Est√°vel</td>
				</tr>
				<tr>
					<td>Selection Sort</td>
					<td>O(n^2)</td>
					<td>O(n^2)</td>
					<td>O(n^2)</td>
					<td>N√£o Est√°vel</td>
				</tr>
			</table>
			<p>
				O melhor caso para o Bubble Sort e o Insertion Sort ocorre quando a lista a ser ordenada j√° est√° ordenada ou quase ordenada, resultando em um tempo de execu√ß√£o de O(n), onde n √© o n√∫mero de elementos na lista. O pior caso para ambos os algoritmos ocorre quando a lista est√° completamente desordenada, resultando em um tempo de execu√ß√£o de O(n^2). <br> <br>

				O melhor caso para o Selection Sort ocorre quando a lista est√° completamente desordenada, resultando em um tempo de execu√ß√£o de O(n^2), que √© o mesmo que o pior caso para o algoritmo. O pior caso tamb√©m ocorre quando a lista est√° completamente desordenada, resultando em um tempo de execu√ß√£o de O(n^2).
			</p>
		</div>
	</div>
	
	<br>

	<div>
		<h1>Anota√ß√µes da aula 20/03/23:</h1>
		<div>
			<h2>Nota√ß√£o Assint√≥tica</h2>
			<p>
				√© a forma como n√≥s trabalhamos a an√°lise de algoritmos de um ponto de vista imparcial, onde avaliamos algoritmos com base em seu desempenho de tempo(n√£o atrelado a segundos)
			</p>
			<div>
				<h3>como se analisa um algoritmo</h3>
				<ul>
					<li>
						tempo de cpu
					</li>
					<li>
						modelo matem√°tico -- F(N)
					</li>
				</ul>
			</div>
			<div>
				<h3>quando um algoritmo √© assintoticamente firme?</h3>
				<p>
					√© quando um algoritmo mant√©m uma taxa de desempenho est√°vel mesmo quando o tamanho de um problema aumenta significativamente. <br>
					por exemplo um algoritmo assintoticamente firme tem seu tempo de execu√ß√£o em uma taxa de crescimento muito mais lenta do que o tamanho do problema(entrada). <br>
					Por exemplo, um algoritmo de ordena√ß√£o que tem um tempo de execu√ß√£o de O(nlogn) √© considerado assintoticamente firme, pois o tempo de execu√ß√£o cresce apenas ligeiramente mais r√°pido do que o tamanho da entrada (n), mesmo para tamanhos de entrada muito grandes.
				</p>
			</div>
			<div>
				<h3>tipos de nota√ß√£o</h3>
				<ul>
					<li>
						<h4>BIG O</h4>
						<p>√© usado para delimitar o limite superior em rela√ß√£o ao tempo. ex: no pior caso meu algoritmo tem O(n¬≤)</p>
						REGRA DA SOMA    O(f(n))  +  O(g(n)) <br>
						‚ñ™ Suponha 3 trechos de programas cujos tempos de execu√ß√£o sejam
						O(n), O(n2) e O(nlogn). <br>
						‚ñ™ O tempo de execu√ß√£o dos 2 primeiros trechos √© O(max(n,n2), que √©
						O(n2). <br>
						‚ñ™ O tempo de execu√ß√£o de todos os 3 trechos √©, ent√£o, O(max(n2,
						nlogn)), que √© O(n2) <br>
					</li>
					<li>
						<h4>Nota√ß√£o little O</h4>
						<p>
							O limite assint√≥tico superior definido pela nota√ß√£o O pode ser <br>
							assintoticamente firme ou n√£o. <br>
							EXEMPLO: <br>
							O limite 2n¬≤ = O(ùëõ¬≤) √© assintoticamente firme <br>
							O limite 2n = O(ùëõ¬≤) n√£o √© assintoticamente firme. <br>
							A nota√ß√£o o √© usada para definir um limite superior que n√£o √©
							assintoticamente firme. <br>
						</p>
					</li>
					<li>
						<h4>Nota√ß√£o theta</h4>
						<p>
							- f(n) = Œò(g(n)) <br>
							‚Ä¢ L√™-se f(n) √© da mesma ordem de g(n). <br>
							‚Ä¢ Œòlimita a fun√ß√£o por fatores constantes. <br>
							- g(n) √© um limite assint√≥tico superior e inferior para f(n)
							ou 
							- g(n) √© um limite assint√≥tico firme para f(n). <br>
						</p>
					</li>
					<li>
						<h4>Nota√ß√£o √¥mega</h4>
						<p>
							f(n) = Œ©(g(n)) <br>
							L√™-se  f(n) √© de ordem no m√≠nimo  g(n) <br>
							Œ© define um limite inferior para a fun√ß√£o,  por um  fator 
							constante. <br>
							f (n) √© um  limite assint√≥tico  inferior para g(n) <br>
							</p>
					</li>
					<li>
						<h4>Nota√ß√£o little √¥mega</h4>
						<p>
							'O limite assint√≥tico inferior definido pela nota√ß√£o œâ pode ser
							assintoticamente firme ou n√£o. <br>
							EXEMPLO: <br>
							O limite 2n2 = œâ(n2) √© assintoticamente firme <br>
							O limite 2n2 = œâ(n) n√£o √© assintoticamente firme. <br>
							A nota√ß√£o œâ √© usada para definir um limite inferior que n√£o √©
							assintoticamente firme.' <br>

						</p>
					</li>
				</ul>
			</div>
		</div>
		<div>
			<h2>instancia de problema</h2>
			A= {1,5,2,3} = #16 -- o limite do problema tende ao infinito
			int = Z
			A¬∫ = {1,2,3,5}
		</div>
		<div>
			<h2>para que serve uma estrutura de dados</h2>
			<p>serve para organizar dados, manipular etc -- formente ligado √°s politicas de uso de dados</p> 
			<p>
				s√£o divididas em 3:
				<ul>
					<li>encadeadas:</li>
					<li>arvores:</li>
					<li>grafos:</li>
				</ul>
			</p>
		</div>
		<div>
			<h2>ordem de crescimento</h2>
			<p>N entradas para T tempos de execu√ß√£o</p>
			<p>para se executar certas entradas, leva-se certo tempo para executar</p>

			<h3>FUN√á√ÉO DE CRESCIMENTO DE TEMPO EM RELA√á√ÉO A ENTRADA DE UM ALGORITMO</h3>
			<P>CADA ALGORITMO TEM UMA ESTRAT√âGIA PROPRIA PARA RESOLVER UM PROBLEMA</P>
			<br>
		</div>
	</div>

	<div>
		<p>REVISAO DE MATEMATICA!!!</p>
		<ul>
			<p>propriedades</p>
			<li>limites</li>
			<li>!!!!logaritmos!!!!</li>
			<li>exponenciais</li>
			<li>pa</li>
			<li>pg</li>
			<li>!!!!somatorio!!!!</li>
			<li>pseudo-c√≥digo</li>
		</ul>
	</div>
</body>
</html>